import asyncio
import contextlib
from typing import Any, Callable, Dict
import uuid

from telegram import Update
from telegram.ext import ContextTypes

from app.config import logger, settings
from app.services.chat import ChatService
from app.telegram.registry import TelegramRegistry
from app.telegram.utils import chunk_message, typing_pulse, escape_markdown, download_photo_as_data_url


class TelegramHandlers:
    def __init__(self, chat_service: ChatService, registry: TelegramRegistry, new_conv_id_factory: Callable[[], str]):
        self.chat_service = chat_service
        self.registry = registry
        self.new_conv_id_factory = new_conv_id_factory

    async def start(self, update: Update, ctx: ContextTypes.DEFAULT_TYPE):
        if not update.effective_user or not update.effective_chat:
            return
        user_id = update.effective_user.id
        # update profile fields
        self.registry.update_profile(
            user_id,
            full_name=update.effective_user.full_name,
            username=update.effective_user.username,
        )
        conv_id = self.registry.get_or_create_active_conversation(user_id, new_conv_id_factory=self.new_conv_id_factory)
        await ctx.bot.send_message(update.effective_chat.id, "–ü—Ä–∏–≤–µ—Ç! –ì–æ—Ç–æ–≤ –ø–æ–º–æ–≥–∞—Ç—å. –ö–æ–º–∞–Ω–¥—ã: /newdialog, /help")
        logger.info(f"/start user_id={user_id} conversation_id={conv_id}")

    async def newdialog(self, update: Update, ctx: ContextTypes.DEFAULT_TYPE):
        if not update.effective_user or not update.effective_chat:
            return
        user_id = update.effective_user.id
        self.registry.update_profile(
            user_id,
            full_name=update.effective_user.full_name,
            username=update.effective_user.username,
        )
        conv_id = self.registry.start_new_conversation(user_id, new_conv_id_factory=self.new_conv_id_factory)
        await ctx.bot.send_message(
            update.effective_chat.id,
            "–ù–∞—á–∏–Ω–∞–µ–º –Ω–æ–≤—ã–π –¥–∏–∞–ª–æ–≥. –ü—Ä–µ–¥—ã–¥—É—â–∏–π –∫–æ–Ω—Ç–µ–∫—Å—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω –∏ —Å–≤—ë—Ä–Ω—É—Ç. –°—Ñ–æ—Ä–º—É–ª–∏—Ä—É–π –∑–∞–Ω–æ–≤–æ, —Å —á–µ–≥–æ –Ω–∞—á–Ω—ë–º.",
        )
        logger.info(f"/newdialog user_id={user_id} conversation_id={conv_id}")

    async def help(self, update: Update, ctx: ContextTypes.DEFAULT_TYPE):
        if not update.effective_user or not update.effective_chat:
            return
        user_id = update.effective_user.id
        self.registry.update_profile(
            user_id,
            full_name=update.effective_user.full_name,
            username=update.effective_user.username,
        )
        # MarkdownV2-formatted help (avoid raw '.' or special chars issues by escaping)
        header = escape_markdown("*–ö–∞–∫ —Å–ø—Ä–∞—à–∏–≤–∞—Ç—å, —á—Ç–æ–±—ã –±—ã–ª–æ –ø–æ–ª–µ–∑–Ω–µ–µ?* ü§ù")
        bullets = [
            escape_markdown("‚Äî –ö–æ—Ä–æ—Ç–∫–æ –æ–ø–∏—à–∏ —Ü–µ–ª—å: —á—Ç–æ —Ö–æ—á–µ—à—å –ø–æ–ª—É—á–∏—Ç—å –≤ –∏—Ç–æ–≥–µ"),
            escape_markdown("‚Äî –î–∞–π –∫–æ–Ω—Ç–µ–∫—Å—Ç: –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞, —è–∑—ã–∫, –≤–µ—Ä—Å–∏—è, –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –ø–æ –≤—Ä–µ–º–µ–Ω–∏/—Ä–µ—Å—É—Ä—Å–∞–º"),
            escape_markdown("‚Äî –ü–æ–∫–∞–∂–∏ –ø—Ä–∏–º–µ—Ä –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –∏–ª–∏ —Ç–µ–∫—É—â–∏–π –∫–æ–¥ ‚Äî –µ—Å–ª–∏ –µ—Å—Ç—å"),
            escape_markdown("‚Äî –£–∫–∞–∂–∏ –∂–µ–ª–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç –æ—Ç–≤–µ—Ç–∞: —à–∞–≥–∏, –∫–æ–¥, —á–µ–∫–ª–∏—Å—Ç"),
        ]
        parts = [header, "\n" + "\n".join(bullets), escape_markdown("\n*–ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —à–∞–±–ª–æ–Ω –ø—Ä–æ–º–ø—Ç–∞:*"),]
        tmpl_code = (
            "–¶–µ–ª—å: ‚Ä¶\n"
            "–ö–æ–Ω—Ç–µ–∫—Å—Ç: ‚Ä¶ (—è–∑—ã–∫/–≤–µ—Ä—Å–∏—è/–ø–ª–∞—Ç—Ñ–æ—Ä–º–∞)\n"
            "–î–∞–Ω–Ω—ã–µ/–∫–æ–¥: ‚Ä¶\n"
            "–§–æ—Ä–º–∞—Ç –æ—Ç–≤–µ—Ç–∞: ‚Ä¶ (–∫–æ—Ä–æ—Ç–∫–æ/–ø–æ—à–∞–≥–æ–≤–æ/–ø—Ä–∏–º–µ—Ä –∫–æ–¥–∞)"
        )
        tmpl_safe = (
            tmpl_code.replace("(", "\\(").replace(")", "\\)").replace(".", "\\.")
        )
        parts.append("```\n" + tmpl_safe + "\n```")
        parts.append(escape_markdown("\n*–ü—Ä–∏–º–µ—Ä—ã:*"))
        ex1_code = (
            "–¶–µ–ª—å: –æ—Ç–ª–∞–¥–∏—Ç—å —Å—Ö–µ–º—É –¥—Ä–∞–π–≤–µ—Ä–∞ MOSFET.\n"
            "–ö–æ–Ω—Ç–µ–∫—Å—Ç: STM32, 12 –í, N-MOSFET, PWM 20 –∫–ì—Ü.\n"
            "–î–∞–Ω–Ω—ã–µ/–∫–æ–¥: —Ñ—Ä–∞–≥–º–µ–Ω—Ç —Å—Ö–µ–º—ã (gate/driver/Rg/–¥–∏–æ–¥), –æ—Å—Ü–∏–ª–ª–æ–≥—Ä–∞–º–º—ã, —Å–∏–º–ø—Ç–æ–º—ã (–ø–µ—Ä–µ–≥—Ä–µ–≤, –∑–≤–æ–Ω).\n"
            "–§–æ—Ä–º–∞—Ç –æ—Ç–≤–µ—Ç–∞: —Å–ø–∏—Å–æ–∫ –ø—Ä–æ–≤–µ—Ä–æ–∫, —Ä–∞—Å—á—ë—Ç Rg/Cgate, —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ —Ä–∞–∑–≤–æ–¥–∫–µ."
        )
        ex2_code = (
            "–¶–µ–ª—å: –æ—Ü–µ–Ω–∏—Ç—å –ø—Ä–æ–≥–∏–± –∫–æ–Ω—Å–æ–ª—å–Ω–æ–≥–æ –±—Ä—É—Å–∞ –≤ CAE.\n"
            "–ö–æ–Ω—Ç–µ–∫—Å—Ç: FreeCAD + CalculiX, Al 6061-T6, –Ω–∞–≥—Ä—É–∑–∫–∞ 150 –ù –Ω–∞ –∫–æ–Ω—Ü–µ, L=200 –º–º, —Å–µ—á–µ–Ω–∏–µ 20x5 –º–º.\n"
            "–§–æ—Ä–º–∞—Ç –æ—Ç–≤–µ—Ç–∞: –ø–æ—à–∞–≥–æ–≤–æ ‚Äî –ö–£/—Å–µ—Ç–∫—É/–º–∞—Ç–µ—Ä–∏–∞–ª, –∏ –ø—Ä–æ–≤–µ—Ä–∫–∞ –∞–Ω–∞–ª–∏—Ç–∏–∫–æ–π (Œ¥ = F*L^3/(3*E*I))."
        )
        ex1_safe = ex1_code.replace("(", "\\(").replace(")", "\\)").replace(".", "\\.")
        ex2_safe = ex2_code.replace("(", "\\(").replace(")", "\\)").replace(".", "\\.")
        parts.append("```\n" + ex1_safe + "\n```")
        parts.append("```\n" + ex2_safe + "\n```")
        parts.append(escape_markdown("–ï—Å–ª–∏ —á—Ç–æ ‚Äî –ø–∏–Ω–≥—É–π, —Ä–∞–∑–±–µ—Ä—ë–º—Å—è –≤–º–µ—Å—Ç–µ ‚ú®"))
        text = "\n".join(parts)
        await ctx.bot.send_message(update.effective_chat.id, text, parse_mode="MarkdownV2")

    async def text_message(self, update: Update, ctx: ContextTypes.DEFAULT_TYPE):
        if not update.message or not update.effective_user or not update.effective_chat:
            return
        user_id = update.effective_user.id
        self.registry.update_profile(
            user_id,
            full_name=update.effective_user.full_name,
            username=update.effective_user.username,
        )
        conv_id = self.registry.get_or_create_active_conversation(user_id, new_conv_id_factory=self.new_conv_id_factory)

        # rate-limit per user
        if not self.registry.can_consume_message(user_id, settings.telegram_daily_message_limit):
            await ctx.bot.send_message(
                update.effective_chat.id,
                f"–î–Ω–µ–≤–Ω–æ–π –ª–∏–º–∏—Ç —Å–æ–æ–±—â–µ–Ω–∏–π –∏—Å—á–µ—Ä–ø–∞–Ω (–¥–æ {settings.telegram_daily_message_limit} –≤ —Å—É—Ç–∫–∏). –ü–æ–ø—Ä–æ–±—É–µ–º –∑–∞–≤—Ç—Ä–∞.",
            )
            return

        if self.registry.in_flight(user_id):
            await ctx.bot.send_message(
                update.effective_chat.id,
                "–Ø –µ—â—ë –¥—É–º–∞—é –Ω–∞–¥ –ø—Ä–æ—à–ª—ã–º –≤–æ–ø—Ä–æ—Å–æ–º ‚Äî —Å–µ–π—á–∞—Å –æ—Ç–≤–µ—á—É –∏ –ø—Ä–æ–¥–æ–ª–∂–∏–º.",
            )
            return

        status_msg = await ctx.bot.send_message(update.effective_chat.id, "‚è≥ –¥—É–º–∞—é –Ω–∞–¥ –æ—Ç–≤–µ—Ç–æ–º‚Ä¶")
        self.registry.set_status(user_id, status_msg.message_id, in_flight=True)

        stop = asyncio.Event()
        pulse = asyncio.create_task(typing_pulse(update.effective_chat.id, ctx.bot, stop))

        try:
            # record usage before processing to deter abuse; safe even if fails later
            self.registry.consume_message(user_id)
            user_text = update.message.text or ""
            # If a photo is attached, prefer the largest size
            image_part = None
            if update.message.photo:
                photo_sizes = update.message.photo
                largest = max(photo_sizes, key=lambda p: p.width * p.height)
                data_url, _ = await download_photo_as_data_url(largest.file_id, ctx.bot)
                image_part = {"type": "input_image", "image_url": data_url}

            if image_part:
                # Build full-context messages using ChatService internals (system + summary + window)
                system_prompt = self.chat_service.prompt_loader.load()
                history = self.chat_service.store.load(conv_id)
                summary_text = None
                if settings.summary_enabled:
                    summary_text = self.chat_service._summarize(conv_id, history)
                msgs = self.chat_service._build_messages(system_prompt, summary_text, history, user_text or "")
                # Replace the last user message with multimodal content (image + optional caption)
                if msgs and msgs[-1].get("role") == "user":
                    msgs[-1] = {
                        "role": "user",
                        "content": [image_part]
                        + ([{"type": "input_text", "text": user_text}] if user_text else []),
                    }
                prev_id = self.chat_service.store.last_assistant_response_id(conv_id)
                kwargs: Dict[str, Any] = {"store": True}
                if prev_id is not None:
                    kwargs["previous_response_id"] = str(prev_id)
                # Call OpenAI with full context
                resp = await asyncio.to_thread(self.chat_service.client.create, msgs, **kwargs)
                assistant_text = self.chat_service._extract_text(resp)
                response_id = getattr(resp, "id", None)

                # Log and store records with masked image marker
                caption = (user_text or "").strip().replace("\n", " ")
                logger.info(
                    f"Telegram multimodal: conversation_id={conv_id} response_id={response_id} caption=\"{caption}\" [IMAGE]"
                )
                from datetime import datetime, timezone
                iso = datetime.now(timezone.utc).isoformat()
                user_record = {
                    "id": str(uuid.uuid4()),
                    "conversation_id": conv_id,
                    "role": "user",
                    "content": ((user_text or "").strip() + ("\n[IMAGE]" if image_part else "")).strip(),
                    "ts": iso,
                    "model": None,
                    "response_id": None,
                }
                self.chat_service.store.append(conv_id, user_record)
                assistant_record = {
                    "id": str(uuid.uuid4()),
                    "conversation_id": conv_id,
                    "role": "assistant",
                    "content": assistant_text,
                    "ts": iso,
                    "model": self.chat_service.model_name,
                    "response_id": response_id,
                }
                self.chat_service.store.append(conv_id, assistant_record)
                # Wrap minimal result
                class _R:
                    def __init__(self, conv_id, text, rid):
                        self.conversation_id = conv_id
                        self.assistant_text = text
                        self.response_id = rid
                result = _R(conv_id, assistant_text, response_id)
            else:
                result = await asyncio.to_thread(self.chat_service.chat, user_text, conv_id)
            stop.set()
            with contextlib.suppress(Exception):
                await ctx.bot.delete_message(update.effective_chat.id, status_msg.message_id)
            for chunk in chunk_message(result.assistant_text):
                await ctx.bot.send_message(update.effective_chat.id, chunk)
        except Exception as e:
            stop.set()
            logger.exception("Telegram text_message error")
            with contextlib.suppress(Exception):
                await ctx.bot.edit_message_text(
                    "‚ö†Ô∏è —á—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫. –ü–æ–ø—Ä–æ–±—É–µ–º –µ—â—ë —Ä–∞–∑?",
                    chat_id=update.effective_chat.id,
                    message_id=status_msg.message_id,
                )
                await asyncio.sleep(6)
                await ctx.bot.delete_message(update.effective_chat.id, status_msg.message_id)
        finally:
            self.registry.clear_status(user_id)
